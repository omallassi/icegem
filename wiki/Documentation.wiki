#summary Documentation draft.

<wiki:toc max_depth="1" />

= Introduction =

Icegem is an extension for GemFire^tm^ which provides serialization mechanism for domain objects out of the box and eliminates the needs to take care of that routine yet unavoidable task. It guarantees best performance in compare with standard java serialization, supports versioning of the model classes and cases where part of the objects are already implementing serialization. 


= Model objects constraints =

Icegem imposes some constraints on model classes. Which are:
  * Model class should have public parameterless constructor, which doesn't declare it could throw any exception.
  * If model class extends another class implicitly, superclass should either conform with previous constraint or it should be serializable as well.
  * It's nested classes should not be serializable.
  * A getter name start with "get", take 0 parameters, returns a value and is not parametrized. 
  * A setter name start with "set", takes 1 parameter and not be parametrized. 

Also object should not contain cyclic references.

= Architecture and implementation =

The architecture of Icegem consists of the four main components:

  * GemFireBeanRegistry
  * HierarchyRegistry
  * DataSerializerGenerator
  * Introspector

=== GemFireBeanRegistry ===

It resides in icegem-spring module, apart from core functionality. And it is just convenient utility for spring-based projects which helps to find all classes for which serialization is required. In short GemFireBeanRegistry scans model packages for classes annotated with @AutoSerialized annotation, creates DataSerializers for them and registeres them with GemFire, so no additional job is required. Usage details you can find below in [Documentation#Spring_Integration Spring Integration] section. There is also section, describes how to use Icegem without icegem-spring - [Documentation#Lib_without_Spring_integration Lib without Spring integration]

=== HierarchyRegistry ===

Takes as parameter list of classes (@AutoSerializable) to be serialized and sends them to DataSerializerGenerator which generates corresponding DataSerializers. HierarchyRegistry then registers these DataSerializers with GemFire serialization framework.

{{{
class RegistryBean {

List<Class<?>> classesList = ...

HierarchyRegistry.registerAll(RegistryBean.class.getClassLoader(), classesList);

...
}
}}}

=== DataSerializerGenerator ===

The main component of the system. It performs main operations of the framework -  generation of DataSerializers for model classes. The algorithm is simple. First class is checked for validity, i.e. it should conform with requirements described in [Document#Model_objects_constraints Model objects constraints] section. Then if class is valid DataSerializerGenerator creates <Class name>DataSerializer class which extends [http://www.gemstone.com/docs/6.0.1/product/docs/japi/com/gemstone/gemfire/DataSerializer.html com.gemstone.gemfire.DataSerializer] class. There are four public method to be implemented within those DataSerializers:
{{{
public Class[] getSupportedClasses();

public int getId();

public boolean toData(Object o, DataOutput out) throws IOException;

public Object fromData(DataInput in) throws IOException, ClassNotFoundException;
}}}

  * `getSupportedClasses()` - this method will return sole class for which serializer is created
  * `getId()` - will return unique identifier of DataSerializer
  * `toData(...)` - will serialize an object to a `DataOutput`
  * `fromData(...)` -will read an object from a `DataInput`

Class generation is performed with the help of [http://www.csg.is.titech.ac.jp/~chiba/javassist/ javassist library]. 

=== Introspector ===   

Introspector performs tasks of checking class validity. 

= Usage instructions =

There are two ways of integrating Icegem into progect - via spring and manually. Both cases are described below:

== Versioning ==

Icegem supports data model versioning. 

Each class with @AutoSerializable annotation should also be annotated with @BeanVersion

{{{
@AutoSerializable(dataSerializerID = 1234234)
@BeanVersion(1)
class Client {
    ...
}
}}}

In accordance to serialization/deserialization process we impose some restrictions:

1. you cann't delete field in elder version

2. a field that doesn't exist in first version should be annotated with @FieldVersion and version from which field appeared

These restrictions refer not only to @AutoSerializable class but also to it's superclasses (except java.lang.Object)

== Spring Integration ==

spring-icegem.jar has useful class to register all files with annotation @AutoSerializable. to use it, you need register it in spring like:

  # define bean with class  com.griddynamics.gemfire.serialization.spring.GemFireBeanRegistry
        e.g. 
{{{
<bean id="icegem"  class="com.griddynamics.gemfire.serialization.spring.GemFireBeanRegistry" scope="singleton">
    ...
</bean>
}}}
  # set property which point to domain model package
        e.g.
{{{
<property name="scanPackages">
    <list>
        <value>com.griddynamics.gemfire.serialization.test.domain</value>
    </list>
</property>
}}}
  # add javassist.jar, icegem-core.jar to ClassPath.

== Lib without Spring integration ==

To use  library without spring-icegem.jar

  # add javassist.jar, icegem-core.jar to ClassPath
  # call HierarchyRegistry.registerAll with two arguments: class loader and list of annotated classes with @AutoSerilizable


= Build description=

  # getting source:  svn checkout http://icegem.googlecode.com/svn/trunk/icegem-read-only
  # building artifacts: mvn install
        p.s. to build a single module: cd module_folder, mvn install
  # testing: mvn test
versioning test disabled (different versions of a class cann't be registered at once). If you want to test them, first run SerializeForVersioning, then enable all tests in DeserializeForVersioning and run the last


= Special cases (mixing auto and manual serialization) =

In a project you can use both annotated classes and casual serializable classes (implementing DataSerializable/Serializable or extending DataSerilizer)

= Performance characteristics =

[http://code.google.com/p/thrift-protobuf-compare/ Thrift-protobuf-compare] project were used for benchmark testing. 
The data value used in the benchmark:

{{{
MediaContent {

   media = Media {
      uri = "http://javaone.com/keynote.mpg"
      title = "Javaone Keynote"
      width = 640
      height = 480
      format = "video/mpg4"
      duration = 18000000    // half hour in milliseconds
      size = 58982400        // bitrate * duration in seconds / 8 bits per byte
      bitrate = 262144       // 256k
      persons = ["Bill Gates", "Steve Jobs"]
      player = JAVA
      copyright = null
   }

   images = [
      Image {
         uri = "http://javaone.com/keynote_large.jpg"
         title = "Javaone Keynote"
         width = 1024
         height = 768
         size = LARGE
      }
      Image {
         uri = "http://javaone.com/keynote_small.jpg"
         title = "Javaone Keynote"
         width = 320
         height = 240
         size = SMALL
      }
   ]

}

}}} 
The data types (“?” indicates an optional value):

{{{
record Image = {
   uri: String
   title: String?
   width: Int32
   height: Int32
   size: Size

   enum Size = { SMALL, LARGE, }
}

record Media = {
   uri: String
   title: String?
   width: Int32
   height: Int32
   format: String
   duration: Int64
   size: Int64
   bitrate: Int32?
   persons: List<String>
   player: Player
   copyright: String?

   enum Player = { JAVA, FLASH, }
}

record MediaContent = {
   images: List<Image>
   media: Media
}

}}}

=== Results ===


<p>
Create an object, serialize it to a byte array, then deserialize it back to an object and access all fields.
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Total%20Time&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:4880,6318,65642&chds=0,72206.2044&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Create an object, serialize it to a byte array.
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Serialization%20Time&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:3157,3676,11949&chds=0,13144.28995&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Serialize the same object (i.e. doesn’t include creation time)
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Serialization%20Time%2Bsame&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:3066,3581,10974&chds=0,12071.73&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Deserialize an object
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Deserialize%20Time&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:1623,2517,53464&chds=0,58811.464250000005&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Deserialize an object and access the top-level fields
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Deserialize%20Time%2Bshal&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:1671,2583,53553&chds=0,58908.41715000001&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>
</p>
<br>
<p>
Often the most expensive operation. To make a fair comparison, all fields of the deserialized instances are accessed – this forces lazy deserializers to really do their work. The raw data below shows additional measurements for deserialization.
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Deserialization%20Time%2Bdeep&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:1722,2641,53692&chds=0,59061.914450000004&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
The size of the serialized data. These numbers may vary depending on the exact data value being used.
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Serialized%20Size&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:263,278,889&chds=0,977.9000000000001&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
The size of the serialized data compressed with Java’s built-in implementation of DEFLATE (zlib).
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Serialization%20Compressed%20Size&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:156,164,523&chds=0,575.3000000000001&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Create an object (using the classes specified by the serialization tool)
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Object%20Creation%20Time&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:122,122,122&chds=0,177.198956&chxt=y&chxl=0:|java-built-in|dataserializable-manual|icegem&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>

= Bucket oriented query service =

This service allows to execute OQL queries on a specified set of buckets. The set of buckets is determined by keys of entries that are stored in such buckets: 
 * real and fake keys can be used (such key should have the same routing object as bucket's keys have);
 * it will be enough to specify one key for each bucket.

Bucket oriented query service can be used both on client and server/peer sides.

{{{
public class BucketOrientedQueryService {
    ...

    public static SelectResults<Object> executeOnBuckets(String queryString, Region region, Set<Object> keys) throws QueryException {
        ...
    }

    public static SelectResults<Object> executeOnBuckets(String queryString, Object[] queryParameters, Region region, Set<Object> keys) throws QueryException {
        ...
    }
}
}}}

Where:
 * `queryString` - OQL query string for execute;
 * `queryParameters` - query parameters;
 * `region` - partitioned region on which query will be executed;
 * `keys` - set of keys that specify buckets;

*Usage example:*

{{{
...
SelectResults<Object> results = BucketOrientedQueryService.executeOnBuckets("SELECT * FROM /data WHERE property = $1", new Object[]{1}, data, new HashSet<Object>(Arrays.asList("key1")));
...
}}}
*Note:* `icegem-core.jar` should be added to a ClassPath of all members in a distributed system where OQL query will be executed.

= Paginated Query =

This component allows to execute paginated queries both from client and peer/server sides. It caches paginated query results in a help region and allows to iterate on them using paginated query API.

*Paginated query creation*

A paginated query can be created and configured using following constructors:
{{{
PaginatedQuery(GemFireCache cache, String regionName, String queryString);
PaginatedQuery(GemFireCache cache, String regionName, String queryString, int pageSize);
PaginatedQuery(GemFireCache cache, String regionName, String queryString, Object[] queryParameters);
PaginatedQuery(GemFireCache cache, String regionName, String queryString, Object[] queryParameters, int pageSize);
}}}

Where:

 * _cache_ - an instance of a peer/server cache (`com.gemstone.gemfire.cache.Cache`) or a client cache (`com.gemstone.gemfire.cache.client.ClientCache`);
 * _regionName_ - a name of a region for querying;
 * _queryString_ - a query string^1^;
 * _queryParameters_ - parameters for query execution;
 * _pageSize_ - a size of page (default is 20).

^1^ query string has some limitations. See a limitations section below.

*Limitations* 

TODO 

*Paginated query API*

TODO

*Usage example:*

TODO