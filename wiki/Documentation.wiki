#summary Documentation draft.

<wiki:toc max_depth="1" />

= Introduction =

Icegem is an extension for GemFire^tm^ which provides serialization mechanism for domain objects out of the box and eliminates the needs to take care of that routine yet unavoidable task. It guarantees best performance in compare with standard java serialization, supports versioning of the model classes and cases where part of the objects are already implementing serialization. 


= Model objects constraints =

Icegem imposes some constraints on model classes. Which are:
  * Model class should have public parameterless constructor, which doesn't declare it could throw any exception.
  * If model class extends another class implicitly, superclass should either conform with previous constraint or it should be serializable as well.
  * It's nested classes should not be serializable.
  * A getter name start with "get", take 0 parameters, returns a value and is not parametrized. 
  * A setter name start with "set", takes 1 parameter and not be parametrized. 

Also object should not contain cyclic references.

= Architecture and implementation =

The architecture of Icegem consists of the four main components:

  * GemFireBeanRegistry
  * HierarchyRegistry
  * DataSerializerGenerator
  * Introspector

=== GemFireBeanRegistry ===

It resides in icegem-spring module, apart from core functionality. And it is just convenient utility for spring-based projects which helps to find all classes for which serialization is required. In short GemFireBeanRegistry scans model packages for classes annotated with @AutoSerialized annotation, creates DataSerializers for them and registeres them with GemFire, so no additional job is required. Usage details you can find below in [Documentation#Spring_Integration Spring Integration] section. There is also section, describes how to use Icegem without icegem-spring - [Documentation#Lib_without_Spring_integration Lib without Spring integration]

=== HierarchyRegistry ===

Takes as parameter list of classes (@AutoSerializable) to be serialized and sends them to DataSerializerGenerator which generates corresponding DataSerializers. HierarchyRegistry then registers these DataSerializers with GemFire serialization framework.

{{{
class RegistryBean {

List<Class<?>> classesList = ...

HierarchyRegistry.registerAll(RegistryBean.class.getClassLoader(), classesList);

...
}
}}}

=== DataSerializerGenerator ===

The main component of the system. It performs main operations of the framework -  generation of DataSerializers for model classes. The algorithm is simple. First class is checked for validity, i.e. it should conform with requirements described in [Document#Model_objects_constraints Model objects constraints] section. Then if class is valid DataSerializerGenerator creates <Class name>DataSerializer class which extends [http://www.gemstone.com/docs/6.0.1/product/docs/japi/com/gemstone/gemfire/DataSerializer.html com.gemstone.gemfire.DataSerializer] class. There are four public method to be implemented within those DataSerializers:
{{{
public Class[] getSupportedClasses();

public int getId();

public boolean toData(Object o, DataOutput out) throws IOException;

public Object fromData(DataInput in) throws IOException, ClassNotFoundException;
}}}

  * `getSupportedClasses()` - this method will return sole class for which serializer is created
  * `getId()` - will return unique identifier of DataSerializer
  * `toData(...)` - will serialize an object to a `DataOutput`
  * `fromData(...)` -will read an object from a `DataInput`

Class generation is performed with the help of [http://www.csg.is.titech.ac.jp/~chiba/javassist/ javassist library]. 

=== Introspector ===   

Introspector performs tasks of checking class validity. 

= Usage instructions =

There are two ways of integrating Icegem into progect - via spring and manually. Both cases are described below:

== Versioning ==

Icegem supports data model versioning. 

Each class with @AutoSerializable annotation should also be annotated with @BeanVersion

{{{
@AutoSerializable(dataSerializerID = 1234234)
@BeanVersion(1)
class Client {
    ...
}
}}}

In accordance to serialization/deserialization process we impose some restrictions:

1. you cann't delete field in elder version

2. a field that doesn't exist in first version should be annotated with @FieldVersion and version from which field appeared

These restrictions refer not only to @AutoSerializable class but also to it's superclasses (except java.lang.Object)

== Spring Integration ==

spring-icegem.jar has useful class to register all files with annotation @AutoSerializable. to use it, you need register it in spring like:

  # define bean with class  com.griddynamics.gemfire.serialization.spring.GemFireBeanRegistry
        e.g. 
{{{
<bean id="icegem"  class="com.griddynamics.gemfire.serialization.spring.GemFireBeanRegistry" scope="singleton">
    ...
</bean>
}}}
  # set property which point to domain model package
        e.g.
{{{
<property name="scanPackages">
    <list>
        <value>com.griddynamics.gemfire.serialization.test.domain</value>
    </list>
</property>
}}}
  # add javassist.jar, icegem-core.jar to ClassPath.

== Lib without Spring integration ==

To use  library without spring-icegem.jar

  # add javassist.jar, icegem-core.jar to ClassPath
  # call HierarchyRegistry.registerAll with two arguments: class loader and list of annotated classes with @AutoSerilizable


= Build description=

 # getting source:  svn checkout http://icegem.googlecode.com/svn/trunk/icegem-read-only
 # building artifacts: mvn install
        p.s. to build a single module: cd module_folder, mvn install
 # testing: mvn test
 # integration testing: mvn verify
versioning test disabled (different versions of a class cann't be registered at once). If you want to test them, first run SerializeForVersioning, then enable all tests in DeserializeForVersioning and run the last
 

= Special cases (mixing auto and manual serialization) =

In a project you can use both annotated classes and casual serializable classes (implementing DataSerializable/Serializable or extending DataSerilizer)

= Performance characteristics =

[http://code.google.com/p/thrift-protobuf-compare/ Thrift-protobuf-compare] project were used for benchmark testing. 
The data value used in the benchmark:

{{{
MediaContent {

   media = Media {
      uri = "http://javaone.com/keynote.mpg"
      title = "Javaone Keynote"
      width = 640
      height = 480
      format = "video/mpg4"
      duration = 18000000    // half hour in milliseconds
      size = 58982400        // bitrate * duration in seconds / 8 bits per byte
      bitrate = 262144       // 256k
      persons = ["Bill Gates", "Steve Jobs"]
      player = JAVA
      copyright = null
   }

   images = [
      Image {
         uri = "http://javaone.com/keynote_large.jpg"
         title = "Javaone Keynote"
         width = 1024
         height = 768
         size = LARGE
      }
      Image {
         uri = "http://javaone.com/keynote_small.jpg"
         title = "Javaone Keynote"
         width = 320
         height = 240
         size = SMALL
      }
   ]

}

}}} 
The data types (“?” indicates an optional value):

{{{
record Image = {
   uri: String
   title: String?
   width: Int32
   height: Int32
   size: Size

   enum Size = { SMALL, LARGE, }
}

record Media = {
   uri: String
   title: String?
   width: Int32
   height: Int32
   format: String
   duration: Int64
   size: Int64
   bitrate: Int32?
   persons: List<String>
   player: Player
   copyright: String?

   enum Player = { JAVA, FLASH, }
}

record MediaContent = {
   images: List<Image>
   media: Media
}

}}}

=== Results ===


<p>
Create an object, serialize it to a byte array, then deserialize it back to an object and access all fields.
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Total%20Time&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:4880,6318,65642&chds=0,72206.2044&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Create an object, serialize it to a byte array.
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Serialization%20Time&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:3157,3676,11949&chds=0,13144.28995&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Serialize the same object (i.e. doesn’t include creation time)
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Serialization%20Time%2Bsame&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:3066,3581,10974&chds=0,12071.73&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Deserialize an object
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Deserialize%20Time&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:1623,2517,53464&chds=0,58811.464250000005&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Deserialize an object and access the top-level fields
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Deserialize%20Time%2Bshal&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:1671,2583,53553&chds=0,58908.41715000001&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>
</p>
<br>
<p>
Often the most expensive operation. To make a fair comparison, all fields of the deserialized instances are accessed – this forces lazy deserializers to really do their work. The raw data below shows additional measurements for deserialization.
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Deserialization%20Time%2Bdeep&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:1722,2641,53692&chds=0,59061.914450000004&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
The size of the serialized data. These numbers may vary depending on the exact data value being used.
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Serialized%20Size&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:263,278,889&chds=0,977.9000000000001&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
The size of the serialized data compressed with Java’s built-in implementation of DEFLATE (zlib).
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Serialization%20Compressed%20Size&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:156,164,523&chds=0,575.3000000000001&chxt=y&chxl=0:|java-built-in|icegem|dataserializable-manual&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>
<p>
Create an object (using the classes specified by the serialization tool)
</p>
<p>
<img src='https://chart.googleapis.com/chart?chtt=Object%20Creation%20Time&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x90&chd=t:122,122,122&chds=0,177.198956&chxt=y&chxl=0:|java-built-in|dataserializable-manual|icegem&chm=N *f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=10,0,10&nonsense=aaa.png'/>

</p>
<br>

= Bucket oriented query service =

This service allows to execute OQL queries on a specified set of buckets. The set of buckets is determined by keys of entries that are stored in such buckets: 
 * real and fake keys can be used (such key should have the same routing object as bucket's keys have);
 * it will be enough to specify one key for each bucket.

Bucket oriented query service can be used both on client and server/peer sides.

{{{
public class BucketOrientedQueryService {
    ...

    public static SelectResults<Object> executeOnBuckets(String queryString, Region region, Set<Object> keys) throws QueryException {
        ...
    }

    public static SelectResults<Object> executeOnBuckets(String queryString, Object[] queryParameters, Region region, Set<Object> keys) throws QueryException {
        ...
    }
}
}}}

Where:
 * `queryString` - OQL query string for execute;
 * `queryParameters` - query parameters;
 * `region` - partitioned region on which query will be executed;
 * `keys` - set of keys that specify buckets;

*Usage example:*

{{{
...
SelectResults<Object> results = BucketOrientedQueryService.executeOnBuckets("SELECT * FROM /data WHERE property = $1", new Object[]{1}, data, new HashSet<Object>(Arrays.asList("key1")));
...
}}}
*Note:* `icegem-core.jar` should be added to a ClassPath of all members in a distributed system where OQL query will be executed.

=Paginated Query=

This component allows to execute paginated queries both from client and peer/server sides. It caches paginated query results in a help region and allows to iterate on them using paginated query API.

==Creation==

A paginated query can be created and configured using following constructors:
{{{
PaginatedQuery(GemFireCache cache, String regionName, String queryString);
PaginatedQuery(GemFireCache cache, int queryLimit, String regionName, String queryString);
PaginatedQuery(GemFireCache cache, String regionName, String queryString, int pageSize);
PaginatedQuery(GemFireCache cache, int queryLimit, String regionName, String queryString, int pageSize);
PaginatedQuery(GemFireCache cache, String regionName, String queryString, Object[] queryParameters);
PaginatedQuery(GemFireCache cache, int queryLimit, String regionName, String queryString, Object[] queryParameters);
PaginatedQuery(GemFireCache cache, String regionName, String queryString, Object[] queryParameters, int pageSize);
PaginatedQuery(GemFireCache cache, int queryLimit, String regionName, String queryString, Object[] queryParameters, int pageSize);
}}}

*Where:*

 * `cache` - an instance of a peer/server cache (`com.gemstone.gemfire.cache.Cache`) or a client cache (`com.gemstone.gemfire.cache.client.ClientCache`);
 * `queryLimit` - a limit on size of query results (default is 1000 entries)^1^;
 * `regionName` - a name of a region for querying;
 * `queryString` - a query string^2^;
 * `queryParameters` - parameters for query execution;
 * `pageSize` - a size of page (default is 20).

^1^ see a "Limiting of results" section below.
^2^ query string has some limitations. See a "Restrictions" section below.

Query can be parametrized by an entry type. For example, a paginated query for working with a region that contains entries of a type `Person` can be created this way:

{{{
PaginatedQuery<Person> query = new PaginatedQuery<Person>(...);
}}} 

==Requirements==

 # Member (client or peer/server) that wants to execute paginated queries must have in it's local cache:
  * region for querying;
  * help region with name `PaginatedQuery.PAGINATED_QUERY_INFO_REGION_NAME` for storing information about paginated queries. Expiration policy should be configured for this region. This region can be partitioned or replicated and must have the following configuration:
{{{ 
Region<PaginatedQueryPageKey, List<Object>> paginatedQueryInfoRegion;
}}}  
 # All members that store help region must have `icegem-core.jar` in it's ClassPath.

==Restrictions== 

 # A query string for paginated query can be arbitrarily complex but must return keys of entries that obtained during the query;
 # For partitioned regions a query string must meet the requirements described in a GemFire documentation for querying partitioned regions.  

==API==

Paginated query support the following methods:

{{{
public class PaginatedQuery<V> {
...
public List<V> page(int pageNumber){...};
public List<V> next(){...};
public List<V> previous(){...};
public boolean hasNext(){...};
public boolean hasPrevious(){...};
public int getPageSize(){...};
public int getTotalNumberOfPages(){...};
public int getTotalNumberOfEntries(){...};
...
}
}}}

*Where method:*

 * `page(int pageNumber)` - returns entries for a specified page number;
 * `next()` - returns next to the current page. For the first call of this method it will be a first page;
 * `previous()` - returns previous to the current page;
 * `hasNext()` - checks that the query has the next page;
 * 'hasPrevious()` - checks that query has the previous page;
 * `getPageSize()` - returns size of page (page size is 20 by default);
 * `getTotalNumberOfPages()` - returns a total number of query pages;
 * `getTotalNumberOfEntries()` - returns a total number of query entries.

==Ordering of results==
Query results will be ordered by entry keys automatically, if a key object implements `java.lang.Comparable` interface.

==Limiting of results==
Paginated query result can be limited. By default this limit is 1000 entries. If query results exceeds this limit, `javax.naming.LimitExceededException` will be thrown. 

==Workflow==

 # Using one of particular constructors member creates a paginated query based on a specified set of parameters.
 # When the member invokes any of paginated query API methods (except `getPageSize()`) the query executes and it's results are stored into a help region. It happens only if query execution results have not been saved before. Otherwise query results loaded from the help region.
 # Cached query results can be used during some period of time (depends on configuration of expiration policy for the help region). After this time query information will be expired and next time the query will be executed and results will be cached again. 

==Usage example==

Get first page of persons from the region `/person`:
{{{
...
ClientCache cache = clientCacheFactory.create();
String queryString = "SELECT * FROM /person.keySet";
int pageSize = 10;
PaginatedQuery<Person> query = new PaginatedQuery<Person>(cache, "person", queryString, pageSize);
if (querty.hasNext()) {
    List<Person> pageEntries = query.next();
}
}}}

Get first page of persons with social number = 534 from the region `/person`:
{{{
...
Cache cache = cacheFactory.create();
String queryString = "SELECT e.key FROM /person.entrySet e WHERE e.value.socialNumber = $1";
int pageSize = 30;
PaginatedQuery<Person> query = new PaginatedQuery<Person>(cache, "person", queryString, new Object[]{534}, pageSize);
List<Person> pageEntries = query.page(1);
}}}

= Smart expiration =

Allows to customize the expiration of region entries. It is possible to define own policy implementing the interface ExpirationPolicy.  


== Example ==

{{{
ExpirationController expirationController = new ExpirationController(
	"127.0.0.1", 10355);

long destroyedEntriesNumberForData = expirationController.process("data",
	new ExpirationPolicy() {

		public boolean isExpired(Entry<Object, Object> entry) {
			// TODO: Add some logic
			return false;
		}
	});

long destroyedEntriesNumberForErrors = expirationController.process("errors",
	new ExpirationPolicy() {

		public boolean isExpired(Entry<Object, Object> entry) {
			// TODO: Add some logic
			return false;
		}
	});

expirationController.close();

}}}

== How to get access to the other regions inside of isExpired(Entry<Object, Object>) method ==

{{{
new ExpirationPolicy() {

  public boolean isExpired(Entry<Object, Object> entry) {
    RegionService regionService = entry.getRegion().getRegionService();
    Region<Long, TransactionProcessingError> errorsRegion = regionService.getRegion("errors");

    // TODO: Add some logic
    return false;
  }
});
}}}

== Processing with delays ==

In case of using the method `ExpirationController#process(String regionName, ExpirationPolicy policy)` the processing node can be blocked if there is a lot of entries. This can block the other processing on this node. 

Due to this we introduce the method `ExpirationController#process(String regionName, ExpirationPolicy policy, long packetSize, long packetDelay)`. It will do the same actions as the method with two parameters but will also stop the processing for `packetDelay` milliseconds after processing each `packetSize` entries.

How it is implemented in ExpirationFunction:
{{{

[...]
long packetDelay = expirationFunctionArguments.getPacketDelay();
long packetSize = expirationFunctionArguments.getPacketSize();

Region<Object, Object> region = PartitionRegionHelper.getLocalDataForContext(context);

Set<Entry<Object, Object>> entrySet = region.entrySet();

long packetCounter = 1;
for (Entry<Object, Object> entry : entrySet) {

  if ((packetDelay > 0) && ((packetCounter % packetSize) == 0)) {
    Thread.sleep(packetDelay);
  }

  if (entry instanceof Region.Entry) {
    Region.Entry<Object, Object> regionEntry = (Region.Entry<Object, Object>) entry;

    if ((policy != null) && policy.isExpired(regionEntry)) {
      region.destroy(entry.getKey());
      destroyedEntriesCount++;
    }
  }

  packetCounter++;
}

}}}

= Cache utils =

Cache utils consists of several utilities which can help with testing, deploying and monitoring of GemFire-related applications.

This is the list of available utils:

  * comparator
  * latency-measure
  * monitor
  * updater
  * signal waiter


== Comparator ==

Compares data of the specified region in specified cache servers (mode REPLICATION) or specified locators of the same cluster. It is also possible to provide list of java packages to restrict comparison.

=== Result of comparison ===

Result of comparison - list of the results for the each checked node. For each node there is complex object which contains:
  * set of missing keys (set of all keys minus set of local keys)
  * set of extra keys (set of local keys minus set of all keys)
  * set of different keys (key is present in both sets - local and all, but values are different)
  * node identifier

=== Usage help ===

This is the application help for the command "comparator":

{{{
D:\Temp\icegem-cache-utils-0.7-SNAPSHOT>java -jar icegem-cache-utils-0.7-SNAPSHOT.jar comparator
usage: comparator
 -c,--packages <arg>   Enumerate packages to scan for @AutoSerializable
                       model classes. Delimiter is a comma sign.
 -h,--help             Print usage information
 -l,--locators <arg>   Locators of GemFire system. For intra-cluster
                       checking. Example: host1[port1],host2[port2]
 -p,--path <arg>       Region path to be compared. Only replicated region
                       could be used. Example: /region1/region2
 -s,--servers <arg>    Servers of GemFire system. For multi-cluster
                       systems. Example: host1[port1],host2[port2]
}}}

The following command will start comparator utility. Replicated region with path "/data" will be compared on the cache servers `localhost[40402]`,`localhost[40403]` and `localhost[40405]` :

{{{
java -jar icegem-cache-utils-0.7-SNAPSHOT.jar comparator -p /data -s localhost[40402],localhost[40403],localhost[40405]
}}}

== Monitor ==

Informs about the changes in the GemFire nodes network. It sends email in case of some node has been added, hanged or removed, and in case of some exception. It is also possible to add custom handlers of the monitoring tool events.

=== Example ===

{{{
MonitoringTool tool = new MonitoringTool();

tool.addNodeEventHandler(new NodeEventHandler() {

	private int count = 0;

	public void handle(NodeEvent event) {
		count++;
	}

	public int getCount() {
		return count;
	}
});

tool.start();

// Monitor works

tool.shutdown();
}}}


=== Configuration ===

All the configuration of the monitoring tool is in the two property files:
  * monitoring.properties - the main configuration file which points the tool to the GemFire network, sets delay and period, configures email texts and setups the email SMTP server settings
  * log4j.properties - configures logging

==== monitoring.properties ====
{{{
# Gmail SMTP settings
mail.smtp.host=smtp.gmail.com
mail.smtp.socketFactory.port=465
mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
mail.smtp.auth=true
mail.smtp.port=465

# Send emails using this account
mail.user=john.smith.sendmail@gmail.com
mail.password=JohnSmithSendmail

# The email FROM address
mail.from=alerts@icegem.googlecode.com
# The addresses to whom send the alert email
mail.to=john.smith.sendmail@gmail.com

# List of locators
com.googlecode.icegem.cacheutils.monitor.locators=localhost[10355]

# Delay before the first run
com.googlecode.icegem.cacheutils.monitor.timer.delay=0

# Period of run
com.googlecode.icegem.cacheutils.monitor.timer.period=10000

# Timeout of the checking function, ms
com.googlecode.icegem.cacheutils.monitor.function.timeout=3000

# Subject of the alert email
com.googlecode.icegem.cacheutils.monitor.email.alert.subject=IceGem monitoring tool alert

# Content of the alert email
com.googlecode.icegem.cacheutils.monitor.email.alert.content=<body style="font: 14px Georgia"><p>The system has changed its status. This is the list of last events:</p>{0}<br /><p>IceGem monitoring tool,<br />{1}</p></body>

# Subject of the exception email
com.googlecode.icegem.cacheutils.monitor.email.exception.subject=IceGem monitoring tool exception

# Content of the exception email
com.googlecode.icegem.cacheutils.monitor.email.exception.content=<body style="font: 14px Georgia"><p>The following exception detected:</p><p>{0}</p><br /><p>IceGem monitoring tool,<br />{1}</p></body>
}}}


==== log4j.properties ====
{{{
# The format of the next line is [log_level, [appender1[,appender2][,appenderN]]]
# log4j.rootLogger=error, stdout, file
log4j.rootLogger=error, stdout

# Console appender
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.conversionPattern=%m%n

# File appender
log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.maxFileSize=1024KB
log4j.appender.file.maxBackupIndex=10
log4j.appender.file.file=monitor.log
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.conversionPattern=%m%n

# Logging levels
log4j.logger.com.googlecode.icegem.cacheutils.monitor=info
}}}

=== Usage help ===

This is the application help for the command "monitor":

{{{
D:\Temp\icegem-cache-utils-0.7-SNAPSHOT>java -jar icegem-cache-utils-0.7-SNAPSHOT.jar monitor
usage: monitor
 -a,--all            Periodically check all the servers related to
                     locators specified in monitoring.properties file
 -h,--help           Print usage information
 -s,--server <arg>   Check one server and exit with status 0 if server
                     alive, or with status 1 if server is dead or down.
                     Server should be in format host[port].
}}}

Examples of usage:
{{{
java -jar icegem-cache-utils-0.7-SNAPSHOT.jar monitor -s localhost[40404]
}}}
Checks that server on host=localhost and port=40404 is alive. Returns exit code `0` in case of the server alive, 1 in case of its down, -1 in case of there is some other error like misconfiguration.


{{{
java -jar icegem-cache-utils-0.7-SNAPSHOT.jar monitor -a
}}}
Monitor will check periodically all the servers related to locators specified in property `icegem.cacheutils.monitor.locators` of property file `monitoring properties`, write to console and log file, and also will send alert messages.

== Updater ==

Simply gets the value for each entry of the region and puts it back to the same key. This cause "update" of the value.

=== Usage help ===

This is the application help for the command "updater":
{{{
D:\Temp\icegem-cache-utils-0.7-SNAPSHOT>java -jar icegem-cache-utils-0.7-SNAPSHOT.jar updater
usage: updater
 -a,--all              Update all regions in system
 -c,--subregions       Indicate whether to update all subregions of
                       mentioned regions
 -h,--help             Print usage information
 -l,--locator <arg>    Locator of GemFire system. Example: host[port]
 -p,--packages <arg>   Enumerate packages to scan for @AutoSerializable
                       model classes. Delimiter is a comma sign.
 -r,--regions <arg>    Enumerate regions to be updated here. Delimiter is
                       a comma sign. Example: region1,region2,region3...
 -s,--server <arg>     Server of GemFire system. Example: host[port]
}}}

Examples of usage:
{{{
java -jar icegem-cache-utils-0.7-SNAPSHOT.jar updater -a -l localhost[10355] -s localhost[40404]
}}}
This will cause updater to update all regions in distributed system with locator `localhost[10355]` and cache server `localhost[40404]`
{{{
java -jar icegem-cache-utils-0.7-SNAPSHOT.jar updater -r region1,region2 -c -l localhost[10355] -s localhost[40404]
}}}
This will cause updater to update regions region1 and region2 with all its' subregions in distributed system with locator `localhost[10355]` and cache server `localhost[40404]`

== Signal Waiter ==

Wait appearance of an object in a region

=== Usage help ===

{{{
java -jar icegem-cache-utils-*-SNAPSHOT.jar signal
-region regionName     where needed key will appear
-locators              locator(s) list in format host[port],..
-key                   key value, that will appear in signal region (java.lang.String)
-timeout               how long utility will check region, in millis (default: 60sec)
-checkInterval         in what period utility will check region, in millis (default: 1 sec)
}}}
Example:

{{{
java -jar icegem-cache-utils-0.7-SNAPSHOT.jar signal -region signalRegion -locators localhost[10334],localhost[10355] -key signalKey
}}}