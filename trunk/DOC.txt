Object Size:
    Bean {} - 0 bit
    Bean {int x} - 4 byte
    Bean {int x, short y, byte z} - 7 byte
    Bean {boolean x} - ???
    Bean {Boolean x} - ???
    Bean {Boolean[] x} - ??? - есть ли схемы сжатия дробнобайтовых полей
    Bean {enum}
    Bean {enum[]}
    Bean {List[]}
    Bean {Beann{boolean} x} - ???
    Bean {Beann{boolean}[] x} - ???
    Bean {List<Beann{boolean}> x} - ???
    Bean {Integer x} - 33 bit
    Bean {List<Integer> x} - ??? (one bit/byte for every index?)
    Bean {Integer[] x} - ??? (one bit/byte for every index?)
    Bean {String x} - ???


---------------------
FIELD TYPE:
    "System types":
        primitives,
        wrappers,
        String - нет ограничений на длину строки и тип символов? (dataoutput/dataserializer/modified UTF-8)
        Object - опиши что там может лежать
        Date: 1) read as Date 2) write as Date |||OR: !Date - throw ex?
        ??? Locale, TimeZone
        ??? BigDecimal / BigInteger
        ??? URL / URI
        ??? Currency
        ??? UUID
        /// Hessian: Calendar, Class, Collection, Enum, Iterator, Locale, Map, Throwable, SqlDate
    "Systems types" arrays of any dimensions
    Collections:
        List
            A: List, ?AL, ?LL,
            B: other interfaces/classes (?RandomList, ..)
            C: self implementors/other libs
        Set
            A:
            B:
            C:
        Map
            A:
            B:
            C:
        Collection
            ???
        Strange: Iterator, Enumeration, Vector, Hashtable, ...
FORBIDDEN FIELD TYPES:
    InputStream, DataInput, File
    Class
    CharSequence, StringBuilder, StringBuffer, etc - use String/char[]/byte[], ???But we use good scheme???
    ???Number - ???use concrete type
    ???Calendar, GregorianCalendar, other children of Calendar (...Budha, Japan)


---------- enum
    - enum может быть как root так и property
    - enum маркается так же как и другие бины
    - если enum не отмаркан - он не сериализуется (таким образом нет возможности сериализовать бины с недоступными сорцами: for example - java.sql.ClientInfoStatus). Предложение - пересылать его в виде строки или перегонять в отмарканный бин.
    - если мы точно знаем конкретный тип на этапе генерации (учтем, что enum - не наследуются) - пересылаем .name() иначе в результате диспечиризации GF использует dataserializer.writeEnum()/readEnum()

---------- inheritance
@SerializedClass
    - для каждого объекта который будет передаваться его тип должен быть маркирован и зарегистрирован
    - для марканого чилда данные парента передадутся внезависимости отмаркан парент или нет
    - аннотация @SerializedClass не наследуется
    - поле может быть немарканного типа, но значение - марканного (пример: Figure: {@SerClass-Oval, @SerClass-Rect})
    - (это нормально - поле немарканного типа, значение марканного, т.е. не ожидается, что искусственно маркируются предки)
    - поле может быть конкретным классом, абстрактным, интерфейсом (???enum, ???collection)
@TransientGetter
    ? маркать можно ?ТОЛЬКО? корректный геттер
    ? маркать можно корректный геттер ?ТОЛЬКО? сериализуемого класса
    - маркать можно любой корректный геттер сериализуемого класса
    - аннотация @TransientGetter не наследуется
    - поле может быть марканного/немарканного типа, но при сериализации учтется только макканнось/немарканность значения
    - [в целом overriding of getter for DTO - bad practice]

---------- procedure of validation
    - проверяется валидность класса (public, @SC, ?enum ?collection)
    - ищутся все методы начинающиеся на get*
    - проверяется валидность getter-ов
    - ко всем геттерам ищутся сеттеры (по имени)
    - проверяется валидность сеттеров-ов


---------- procedure of serialization
    - потеря типа:
        ? field:List -> value:ArrayList (or AR->AR, LL->LL, other->AR)
        - field:ArrayList -> value:ArrayList
        - field:LinkedList -> value:LinkedList
        - field:Collection -> value:AR
        - field:Map -> value:HM (or HM->HM, ?->?, other->HM)
        - field:HashMap -> value:HM
        - field:HashMap -> value:HM 
